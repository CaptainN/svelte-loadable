{#if state === STATES.ERROR}
  <slot name="error"/>
{:elseif state === STATES.TIMEOUT}
  <slot name="timeout"/>
{:elseif state === STATES.LOADING}
  <slot name="loading"/>
{:elseif state === STATES.SUCCESS && component}
  {#if hasSuccessSlot}
    <slot name="success"/>
  {:else}
    <svelte:component this={component}/>
  {/if}
{/if}

<script>
  const STATES = Object.freeze({
    INITIALIZED: 0,
    LOADING: 1,
    SUCCESS: 2,
    ERROR: 3,
    TIMEOUT: 4,
  })

  export default {
    data() {
      return {
        delay: 0,
        timeout: null,
        loader: null,
        component: null,
        error: null,
        _loadTimer: null,
        _timeoutTimer: null,
        state: STATES.INITIALIZED,
        STATES,
      }
    },
    oncreate() {
      if (!this.options.data) {
        return console.error('[svelte-loadable] No data passed to <Loadable/>')
      }

      if (this.options.slots && this.options.slots.success) {
        this.set({ hasSuccessSlot: true })
      }
      this.load()
    },
    methods: {
      _clearTimers() {
        const { _loadTimer, _timeoutTimer } = this.get()
        clearTimeout(_loadTimer)
        clearTimeout(_timeoutTimer)
      },
      load() {
        const { loader, delay, timeout } = this.get()
        this._clearTimers()

        if (typeof loader === 'function') {
          this.set({
            _loadTimer: setTimeout(() => {
              this.set({
                state: STATES.LOADING,
                error: null,
                component: null,
              })
            }, parseFloat(delay)),
          })

          if (timeout) {
            this.set({
              _timeoutTimer: setTimeout(() => {
                this.set({ state: STATES.TIMEOUT })
              }, parseFloat(timeout)),
            })
          }

          loader()
            .then(componentModule => {
              this.set({
                state: STATES.SUCCESS,
                component: componentModule.default || componentModule,
              })
              this._clearTimers()
            })
            .catch(error => {
              this.set({
                state: STATES.ERROR,
                error,
              })
              this._clearTimers()
            })
        }
      },
    },
  }
</script>